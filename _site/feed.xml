<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://week-with-me.github.io/TWIL/feed.xml" rel="self" type="application/atom+xml" /><link href="https://week-with-me.github.io/TWIL/" rel="alternate" type="text/html" /><updated>2021-08-02T23:43:32+09:00</updated><id>https://week-with-me.github.io/TWIL/feed.xml</id><title type="html">매주 한 편 적는 개발 일지 프로젝트, TWIL(This Week I Learned)</title><subtitle>매주 한 편 적는 개발 일지 프로젝트, TWIL(This Week I Learned)</subtitle><author><name>이주</name></author><entry><title type="html">자바의 연산자</title><link href="https://week-with-me.github.io/TWIL/2%EA%B8%B0/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%97%B0%EC%82%B0%EC%9E%90/" rel="alternate" type="text/html" title="자바의 연산자" /><published>2021-07-18T00:00:00+09:00</published><updated>2021-07-18T00:00:00+09:00</updated><id>https://week-with-me.github.io/TWIL/2%EA%B8%B0/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%97%B0%EC%82%B0%EC%9E%90</id><content type="html" xml:base="https://week-with-me.github.io/TWIL/2%EA%B8%B0/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%97%B0%EC%82%B0%EC%9E%90/">&lt;h1 id=&quot;연산자-operator&quot;&gt;연산자 (Operator)&lt;/h1&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;p&gt;연산자는 &lt;strong&gt;연산을 수행하는 기호&lt;/strong&gt; 를 의미한다. 쉽게 사칙연산을 의미한다고 생각하면 편하다. 이때 연산을 수행하면서 연산의 대상이 되는 &lt;strong&gt;피연산자(operand)&lt;/strong&gt; , 연산자와 피연산자를 조합하여 표현한 &lt;strong&gt;식(expression)&lt;/strong&gt; 과 &lt;strong&gt;문장(statement)&lt;/strong&gt; 그리고 &lt;strong&gt;평가(evaluation)&lt;/strong&gt; 의 개념이 생긴다. 정리하면 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;연산자 관련 개념 정리&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;연산자 (operator):&lt;/strong&gt; 연산을 수행하는 기호 ( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt; 등)
&lt;strong&gt;피연산자 (operand):&lt;/strong&gt; 연산자의 작업 대상 (변수, 상수, 리터럴, 수식)
&lt;strong&gt;식 (expression):&lt;/strong&gt; 연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현한 것
&lt;strong&gt;문장 (statement):&lt;/strong&gt; 작성한 식의 끝에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;;&lt;/code&gt; 를 붙여 프로그램에서 실행될 수 있게 표현한 것
&lt;strong&gt;평가 (evaluation):&lt;/strong&gt; 식을 계한하여 결과를 얻는 것&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;대입-연산자&quot;&gt;대입 연산자&lt;/h2&gt;

&lt;p&gt;위 개념을 통해서 우리는 식을 통해 얻은 결괏값을 얻는 걸 평가라고 한다는 걸 알게 되었다. 프로그래밍에서는 얻게 된 결과를 어딘가에 저장해야 이를 다시 활용할 수 있기 때문에, 다시 말해 &lt;strong&gt;연산의 결괏값을 메모리에 저장&lt;/strong&gt; 해야 이를 기억하여 사용할 수 있기 때문에 대입연산자( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=&lt;/code&gt; , assignment operator)를 사용하여 어떤 특정 변수에 저장해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;종류&quot;&gt;종류&lt;/h2&gt;

&lt;p&gt;연산자의 종류를 기능별로 분류하면 아래 이미지와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/1.jpg&quot; alt=&quot;연산자의 종류&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 피연산자의 개수에 의해서도 분류할 수 있다. 예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-3 - 5&lt;/code&gt; 와 같은 식이 있을 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt; 앞에 붙어 있는 연산자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt; 는 부호 연산자로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt; 을 음수로 정의해준다. 반면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-3&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt; 사이에 있는 연산자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt; 는 뺄셈 연산자로 피연산자가 두 개가 필요하다. 이처럼 &lt;strong&gt;동일한 기호더라도 피연산자의 개수로 인해 연산자의 역할이 구분&lt;/strong&gt; 될 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;우선순위와-결합규칙&quot;&gt;우선순위와 결합규칙&lt;/h2&gt;

&lt;h3 id=&quot;우선순위&quot;&gt;우선순위&lt;/h3&gt;

&lt;p&gt;식에 사용된 연산자가 둘 이상인 경우 연산자의 우선순위가 존재해야 연산순서를 결정할 수 있다. 학창시절 수학에서 덧셈( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; )과 뺄셈( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt; )보다 곱셈( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; )과 나눗셈( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt; )의 우선순위가 더 높다는 것을 배웠을 것이다. 이처럼 대부분의 우선순위는 상식 선에서 해결된다.&lt;/p&gt;

&lt;h3 id=&quot;결합규칙&quot;&gt;결합규칙&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;하나의 식에 같은 우선순위의 연산자들이 여러 개 있는 경우에도 정해진 순서가 있다.&lt;/strong&gt; 이 규칙을 연산자의 결합규칙이라 한다. 대부분 왼쪽에서 오른쪽의 순서로 연산을 수행하며 단항 연산자와 대입 연산자만 그 반대인 오른쪽에서 왼쪽으로 연산을 수행한다.&lt;/p&gt;

&lt;h3 id=&quot;결론&quot;&gt;결론&lt;/h3&gt;

&lt;p&gt;우선순위와 결합규칙을 하나의 표로 정리하면 아래 이미지와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2.png&quot; alt=&quot;연산자의 결합규칙&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 간단하게 아래와 같이 세 가지만 기억하도록 하자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;산술 &amp;gt; 비교 &amp;gt; 논리 &amp;gt; 대입 연산자의 순서로 우선순위가 높다.&lt;/li&gt;
  &lt;li&gt;단항 (1) &amp;gt; 이항 (2) &amp;gt; 삼항 (3) 연산자의 순서로 우선순위가 높다.&lt;/li&gt;
  &lt;li&gt;단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;산술-변환-usual-arithmetic-conversion&quot;&gt;산술 변환 (usual arithmetic conversion)&lt;/h2&gt;

&lt;h3 id=&quot;정의-1&quot;&gt;정의&lt;/h3&gt;

&lt;p&gt;이항 연산자는 &lt;strong&gt;두 피연산자의 자료형이 일치해야 연산이 가능&lt;/strong&gt; 하다. 따라서 피연산자의 자료형이 서로 다르다면 연산 전에 형변환 연산자( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(type)&lt;/code&gt; )를 사용하여 자료형을 일치시켜야 한다. &lt;strong&gt;대부분의 형변환은 두 피연산자 중 더 큰 자료형을 기준으로 일치&lt;/strong&gt; 시키는데 더 작은 크기의 자료형으로 일치시킬 경우 값이 손실될 가능성이 있기 때문이다.&lt;/p&gt;

&lt;p&gt;변수 파트에서 더 큰 자료형으로 형변환을 할 경우 자동 형변환(type promotion)이 되는 걸 배웠다. 이와 같이 연산 전에 &lt;strong&gt;피연산자의 자료형을 일치시키기 위해 자동 형변환&lt;/strong&gt; 되는 것을 &lt;strong&gt;산술 변환&lt;/strong&gt; 또는 &lt;strong&gt;일반 산술 변환&lt;/strong&gt; 이라 하며 이는 이항 연산자 뿐만 아니라 단항 연산에서도 발생한다.&lt;/p&gt;

&lt;h3 id=&quot;규칙&quot;&gt;규칙&lt;/h3&gt;

&lt;p&gt;이때 산술 변환에는 세 가지 규칙이 있다.&lt;/p&gt;

&lt;p&gt;첫 번째는 앞서 정의에서 살펴봤듯이 값손실을 최소화하기 위해, 이를 테면 오버플로우(overflow)와 같은 현상을 예방하기 위해 더 큰 크기의 자료형을 기준으로 자료형을 일치시킨다는 것이다.&lt;/p&gt;

&lt;p&gt;두 번째는 정수형의 기본 타입인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형이 가장 효율적으로 처리할 수 있는 자료형이기 때문에 그보다 작은 자료형인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byte&lt;/code&gt; ,  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;short&lt;/code&gt; 의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형으로 변환된다.&lt;/p&gt;

&lt;p&gt;세 번째는 연산결과의 자료형이 피연산자의 자료형과 일치하는데 이를 테면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5 / 2&lt;/code&gt; 식의 결괏값은 피연산자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; 가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형이기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.5&lt;/code&gt; 가 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; 가 된다.&lt;/p&gt;

&lt;p&gt;이를 정리하면 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;두 피연산자의 자료형을 같게 일치시키는데 이때 크기가 더 큰 자료형을 기준으로 한다.&lt;/li&gt;
  &lt;li&gt;피연산자의 자료형이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 보다 작을 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형으로 변환된다.&lt;/li&gt;
  &lt;li&gt;연산결과의 자료형은 피연산자의 자료형과 일치한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;피연산자의-개수&quot;&gt;피연산자의 개수&lt;/h1&gt;

&lt;h2 id=&quot;단항-연산자&quot;&gt;단항 연산자&lt;/h2&gt;

&lt;h3 id=&quot;증감-연산자&quot;&gt;증감 연산자&lt;/h3&gt;

&lt;p&gt;피연산자에 저장된 값을 1 증가( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;++&lt;/code&gt; ) 또는 감소( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&lt;/code&gt; )시킨다. 이때 유의할 점은 증감 연산자의 위치인데 만약 &lt;strong&gt;피연산자의 왼쪽에 위치할 경우 이를 전위형(prefix)이라 하며 값이 참조되기 전에 증가&lt;/strong&gt; 시킨다. 반대로 &lt;strong&gt;오른쪽에 위치할 경우 이를 후위형(postfix)이라 하며 값이 참조된 후에 증가&lt;/strong&gt; 시킨다.&lt;/p&gt;

&lt;p&gt;아래 이미지와 같이 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tmp1&lt;/code&gt; 의 경우 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 에 증가 연산자( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;++&lt;/code&gt; )를 후위형으로 사용했기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tmp1&lt;/code&gt; 의 값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt; 가 되고 그 뒤에 값이 증가되어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6&lt;/code&gt; 이 된다. 반대로 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tmp2&lt;/code&gt; 의 경우 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt; 에 증가 연산자( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;++&lt;/code&gt; )를 전위형으로 사용했기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt; 가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6&lt;/code&gt; 이 된 이후 참조되어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tmp2&lt;/code&gt; 의 값도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6&lt;/code&gt; 이 된다. 따라서 위치에 따라 결괏값이 달라지는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/3.png&quot; alt=&quot;증감 연산자&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;부호-연산자&quot;&gt;부호 연산자&lt;/h3&gt;

&lt;p&gt;부호 연산자( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt; )는 피연산자의 부호를 반대로 변경한 결과를 반환한다. 다시 말해 피연산자가 음수면 양수로, 양수면 음수로 부호를 바꿔 반환한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boolean&lt;/code&gt; 형과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt; 형을 제외한 기본형에서만 사용 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;기타&quot;&gt;기타&lt;/h3&gt;

&lt;p&gt;이외에도 단항 연산자의 종류로는 &lt;strong&gt;논리부정 연산자( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!&lt;/code&gt; )&lt;/strong&gt; 와 &lt;strong&gt;비트전환 연산자( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~&lt;/code&gt; )&lt;/strong&gt; 가 있지만 이는 편의상 뒤 논리 연산자 부분과 비트 연산자 부분에서 다룰 예정이다.&lt;/p&gt;

&lt;h2 id=&quot;산술-연산자&quot;&gt;산술 연산자&lt;/h2&gt;

&lt;h3 id=&quot;사칙-연산자&quot;&gt;사칙 연산자&lt;/h3&gt;

&lt;p&gt;앞서 설명한 것처럼 곱셈( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; ), 나눗셈( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt; ), 나머지( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%&lt;/code&gt; ) 연산자가 덧셈( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; ), 뺄셈( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt; ) 연산자보다 우선순위가 높다. 또한 피연산자가 정수형인 경우 나누는 수로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 을 사용할 수 없으며 아래 이미지와 같이 나누기 연산자의 두 피연산자가 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형일 경우 연산결과 역시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형이다. 따라서 결괏값으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.5&lt;/code&gt; 가 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; 가 출력된다. 이때 결괏값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt; 이 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; 인 이유는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형은 소수점을 저장하지 못하형 정수만 남고 소수점 이하는 버려지기 때문이다. 여기서 정수를 나눌 때 버림을 수행한다는 사실을 기억하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/4.png&quot; alt=&quot;나머지 연산의 버림&quot; /&gt;&lt;/p&gt;

&lt;p&gt;중요한 점은 자동 형변환이 되더라도 명시적으로 해주지 않으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형끼리의 연산결과는 결국 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형이라는 점이다. 아래 이미지를 한 번 같이 살펴보자. 결괏값으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2_000_000_000_000&lt;/code&gt; 이 출력될 것 같지만 전혀 다른 수인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1_454_759_936&lt;/code&gt; 이 출력됐다. 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;firstNum&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;secondNum&lt;/code&gt; 의 곱셈( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; ) 결괏값의 자료형이 결국 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형이기 때문에 오버플로우가 발생한 뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 타입 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;res&lt;/code&gt; 에 저장됐기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/5.png&quot; alt=&quot;연산결과의 의도치 못한 오버플로우&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사칙 연산자 중 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; 연산자의 경우 리터럴 간의 연산으로도 사용할 수 있는데 아래 이미지를 한 번 살펴보자. 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c2&lt;/code&gt; 의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt; 타입이기 때문에 연산결과의 타입인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 와 매칭이 되지 않아 컴파일 오류가 발생한다. 그러나 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c3&lt;/code&gt; 의 경우 &lt;strong&gt;리터럴 간의 연산&lt;/strong&gt; 으로 되기 때문에 컴파일러가 이를 계산하여 미리 덧셈연산을 수행한다. 따라서 컴파일 오류가 발생하지 않는 것이다. 컴파일러는 변수를 미리 계산할 수 없기 때문에 리터럴을 사용하는 경우에만 가능하다는 걸 잊지말자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/6.png&quot; alt=&quot;리터럴 연산&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;나머지-연산자&quot;&gt;나머지 연산자&lt;/h3&gt;

&lt;p&gt;나머지 연산자는 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과고 반환하는 연산자다. 이를 공식으로 나타내면 다음과 같다. $a - (a / b) * b$  다시 말해 왼쪽의 피연산자인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 에 따라서 부호가 결정된다. 아래 이미지에서 출력되는 결괏값을 보면 이를 쉽게 이해할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/7.png&quot; alt=&quot;나머지 연산의 버림&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이게 중요한 이유는 바로 홀수와 짝수를 구별할 때 발생한다. 보통 나머지 연산자( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%&lt;/code&gt; )를 활용해서 구하게 되는데 만약 아래 이미지와 같이 나머지가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 인 경우로 따지게 되면 왼쪽 피연산자의 부호에 따라 값이 달라지기 때문에 제대로 구별할 수 없게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/8.png&quot; alt=&quot;홀수-짝수 구별 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 음수의 경우에도 제대로 홀수와 짝수를 구별하려면 어떻게 해야할까? 이때는 아래 이미지와 같이 나머지 연산의 결괏값을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 과 비교하는 것이 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 과 비교하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/9.png&quot; alt=&quot;홀수-짝수 구별 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;물론 이 방법보다 더 효율적인 방법은 비트 연산자 중 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AND&lt;/code&gt; ( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; )를 사용하는 방법이 있다. 모든 비트의 첫 번째 자리가 곧 부호를 나타내기 때문이다. 이는 뒤에 비트 연산자에서 알아보고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;비교-연산자&quot;&gt;비교 연산자&lt;/h2&gt;

&lt;h3 id=&quot;정의-2&quot;&gt;정의&lt;/h3&gt;

&lt;p&gt;비교 연산자는 두 피연산자를 비교하는 데 사용되는 연산자로 관계 연산자라고도 한다. 주로 조건문 또는 반복문의 조건식에 사용되며 연산결과로 얻게 되는 값은 오직 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; 둘 중 하나다. 비교 연산자 역시 이항 연산자이기 때문에 피연산자의 자료형이 서로 다를 경우 자동 형변환을 통해 자료형을 일치시킨 후 비교를 수행한다는 점을 유의해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;대소비교-연산자&quot;&gt;대소비교 연산자&lt;/h3&gt;

&lt;p&gt;두 피연산자 값의 크기를 비교하는 연산자다. 이때 기준은 좌변 값이며 종류로는 큰 경우( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; ), 작은 경우 ( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; ), 크거나 같은 경우( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;=&lt;/code&gt; ), 작거나 같은 경우( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;=&lt;/code&gt; )가 있다. 기본형 중에서는 논리형인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boolean&lt;/code&gt; 을 제외한 나머지 자료형에서 다 사용할 수 있지만 참조형에서는 사용할 수 없다.&lt;/p&gt;

&lt;h3 id=&quot;등가비교-연산자&quot;&gt;등가비교 연산자&lt;/h3&gt;

&lt;p&gt;두 피연산자의 값이 같은지 또는 다른지 비교하는 연산자다. 대소비교 연산자와 달리 기본형은 물론 참조형까지 포함하여 모든 자료형에서 사용할 수 있다. &lt;strong&gt;기본형에 사용할 경우 변수에 저장되어 있는 값이 같은지&lt;/strong&gt; 를 알 수 있고 &lt;strong&gt;참조형의 경우 객체의 주소값을 저장하기 때문에 두 피연산자(참조변수)가 같은 객체를 가리키고 있는지&lt;/strong&gt; 알 수 있다. 종류로는 같은 경우( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt; )와 다른 경우( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!=&lt;/code&gt; )가 있다.&lt;/p&gt;

&lt;h2 id=&quot;논리-연산자&quot;&gt;논리 연산자&lt;/h2&gt;

&lt;p&gt;논리 연산자는 둘 이상의 조건을 그리고( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AND&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&amp;amp;&lt;/code&gt; )나 또는( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OR&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;||&lt;/code&gt; )으로 연결하여 하나의 식으로 표현할 수 있게 해준다. 이를 간단하게 표로 표현하면 아래 이미지와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/10.jpg&quot; alt=&quot;논리 연산자&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;효율적인-연산-short-circuit-evaluation&quot;&gt;효율적인 연산 (short circuit evaluation)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;논리 연산자의 경우 효율적인 연산이 가능&lt;/strong&gt; 하다. 위 이미지를 보면 알 수 있듯 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;||&lt;/code&gt; 연산자의 경우 &lt;strong&gt;어느 한 쪽만 참( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; )&lt;/strong&gt; 이어도 연산결과가 참이기 때문에 좌측 피연산자가 참( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; )이면 우측 피연산자의 값을 평가하지 않는다. 반대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산자의 경우 &lt;strong&gt;한쪽만 거짓( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; )&lt;/strong&gt; 이어도 연산결과가 거짓이기 때문에 좌측 피연산자가 거짓( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; )이면 우측 피연산자의 값은 평가하지 않는다. 따라서 이러한 위치에 따라 효율이 달라질 수 있기 때문에 어떤 연산자를 사용하여 조건을 어느 위치에 둘 것인지 고려하는 것이 효율적인 식을 표현할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;논리-부정-연산자&quot;&gt;논리 부정 연산자&lt;/h3&gt;

&lt;p&gt;논리 부정 연산자( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!&lt;/code&gt; )는 피연산자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; 를, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; 면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 를 결괏값으로 반환한다.&lt;/p&gt;

&lt;h2 id=&quot;비트-연산자&quot;&gt;비트 연산자&lt;/h2&gt;

&lt;h3 id=&quot;논리-연산자-1&quot;&gt;논리 연산자&lt;/h3&gt;

&lt;p&gt;피연산자를 비트단위로 논리 연산한다. 피연산자를 이진수로 표현하여 아래와 같은 규칙을 통해 연산을 수행한다. 이때 중요한 점은 피연산자로 실수를 허용하지 않는다는 점이다. 정수 또는 문자만 허용된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt; ( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OR&lt;/code&gt; 연산자)&lt;/p&gt;

    &lt;p&gt;피연산자 중 &lt;strong&gt;한 쪽의 값&lt;/strong&gt; 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 이면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 을 결과로 얻는다. 그 외에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 을 얻는다. 주로 특정 비트의 값을 변경할 때 사용한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; ( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AND&lt;/code&gt; 연산자)&lt;/p&gt;

    &lt;p&gt;피연산자 중 &lt;strong&gt;양 쪽이 모두&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 이어야만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 을 결과로 얻는다. 그 외에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 을 얻는다. 주로 특정 비트의 값을 뽑아낼 때 사용한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^&lt;/code&gt; ( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XOR&lt;/code&gt; 연산자)&lt;/p&gt;

    &lt;p&gt;피연산자의 값이 &lt;strong&gt;서로 다를 때만&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 을 결과로 얻는다. 같을 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 을 얻는다. 간단한 암호화에 사용되는 경우가 많다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;잠깐! 이때 2진수로 표현된 결괏값을 확인하기 위해 보통 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;toBinaryString()&lt;/code&gt; 메서드를 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞서 나머지 연산자( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%&lt;/code&gt; )에서 살펴보았던 비트 연산자를 활용한 홀수-짝수 판별법을 알아보자. 아래 이미지와 같이 식을 나타낼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/11.png&quot; alt=&quot;홀수-짝수 구별 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2진수에서 홀수-짝수를 결정짓는 숫자는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2^0&lt;/code&gt; 인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 이다. 왜냐하면 나머지 자리는 결국 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2^n&lt;/code&gt; 형태로 수를 표현하기 때문에 나머지는 전부 짝수이기 때문이다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 이 존재하면 홀수 그렇지 않으면 짝수가 된다. 따라서 위 이미지와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;num&lt;/code&gt; 을 비트 연산자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 를 사용하여 계산하게 될 경우 만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;num&lt;/code&gt; 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10&lt;/code&gt; 일 경우 2진수로 표현하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1010&lt;/code&gt; 이 되고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2^0&lt;/code&gt; 자리의 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 이기 때문에 이것과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 을 비교하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; 가 결괏값으로 반환된다.&lt;/p&gt;

&lt;h3 id=&quot;비트-전환-연산자&quot;&gt;비트 전환 연산자&lt;/h3&gt;

&lt;p&gt;논리부정 연산자( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!&lt;/code&gt; )와 유사하며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 은  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 으로 바꾼다. 이를 통해 결국 부호가 있는 피연산자는 부호가 반대로 바뀌게 된다. 다시 말해 1의 보수를 얻게 되는 것이다. 따라서 비트 전환 연산자를 1의 보수 연산자라고도 한다. 따라서 어떤 정수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; 의 음수값을 얻고 싶을 때는 비트 전환 연사자( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~&lt;/code&gt; )를 활용하여 1의 보수를 얻은 뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 을 더해줘, 다시 말해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~p + 1&lt;/code&gt; 과 같은 식을 통해 값을 얻을 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;쉬프트-연산자&quot;&gt;쉬프트 연산자&lt;/h3&gt;

&lt;p&gt;피연산자의 각 자리를 2진수로 표현했을 때 오른쪽( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt; ) 또는 왼쪽( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&lt;/code&gt; )으로 이동(shift)한다고 해서 쉬프트 연산자(shift operator)라고 이름이 붙여졌다. 예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8 &amp;lt;&amp;lt; 2&lt;/code&gt; 인 경우 피연산자인 10진수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8&lt;/code&gt; 을 2진수로 표현한 뒤 왼쪽으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; 자리 이동한다. 이때 저장범위를 벗어난 값들은 버려지고 양수의 경우 빈자리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 으로, 음수의 경우 빈자리는 부호로 인해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 로 채워진다.&lt;/p&gt;

&lt;p&gt;예를 들어 아래 이미지와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8 &amp;lt;&amp;lt; 2&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8&lt;/code&gt; 의 2진수를 왼쪽으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; 자리 이동시키고 저장범위를 벗어난 값은 버려져 빈자리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 으로 채워진 뒤 결괏값을 얻게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/12.jpg&quot; alt=&quot;쉬프트 연산자 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;반대로 아래 이미지와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-8 &amp;gt;&amp;gt; 2&lt;/code&gt; 인 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-8&lt;/code&gt; 의 2진수를 오른쪽으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; 자리 이동시키고 저장범위를 벗어난 값은 버려져 빈자리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 로 채워진 뒤 결괏값을 얻게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/13.png&quot; alt=&quot;쉬프트 연산자 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이를 식으로 표현하면 다음과 같다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x &amp;lt;&amp;lt; n&lt;/code&gt; 의 경우 $x * 2^n$ 과 결괏값이 동일하며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x &amp;gt;&amp;gt; n&lt;/code&gt; 의 경우 $x / 2^n$ 과 결괏값이 동일하다. 곱셈이나 나눗셈 연산자보다 훨씬 빠른 연산결과를 얻을 수 있지만 가독성 때문에 실행속도가 중요한 경우에만 사용하는 게 좋다.&lt;/p&gt;

&lt;h2 id=&quot;대입-연산자-1&quot;&gt;대입 연산자&lt;/h2&gt;

&lt;h3 id=&quot;정의-3&quot;&gt;정의&lt;/h3&gt;

&lt;p&gt;대입 연산자는 변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장하는데 사용된다. 이 연산자는 오른쪽 피연산자의 값(식이라면 평가값)을 왼쪽 피연산자에 저장한다. 그리고 저장된 값을 연산결과로 반환한다. 이때 대입 연산자는 우리가 앞서 우선순위에서 살펴본 것처럼 가장 낮은 우선순위를 가지고 있기 때문에 식에서 제일 나중에 수행된다. 또한 연산 진행 방향이 오른쪽에서 왼쪽으로 진행된다.&lt;/p&gt;

&lt;h3 id=&quot;lvalue와-rvalue&quot;&gt;lvalue와 rvalue&lt;/h3&gt;

&lt;p&gt;대입 연산자의 &lt;strong&gt;왼쪽에 위치한 피연산자를 lvalue(left value)&lt;/strong&gt; 라 하고 &lt;strong&gt;오른쪽에 위치한 피연산자를 rvalue(right value)&lt;/strong&gt; 라 한다. 이때 rvalue에는 변수 뿐만 아니라 식, 상수 등 모든 값이 올 수 있지만 &lt;strong&gt;lvalue에는 변수처럼 변경 가능한 값만&lt;/strong&gt; 올 수 있다. 예를 들어 아래 이미지와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt; 키워드를 사용해 선언한 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAX&lt;/code&gt; 값을 변화시키려고 시도한 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cannot assign a value to final variable 'MAX'&lt;/code&gt; 라는 오류를 반환받는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/14.png&quot; alt=&quot;대입 연산자의 lvalue&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;복합-대입-연산자&quot;&gt;복합 대입 연산자&lt;/h3&gt;

&lt;p&gt;대입 연산자는 다른 연산자와 결합하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+=&lt;/code&gt; 와 같은 형태로 사용할 수 있다. 이때 유의할 점은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i *= 10 + j&lt;/code&gt; 와 같은 식일 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i = (i * 10) + j&lt;/code&gt; 와 같은 식이 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i = i * (10 + j)&lt;/code&gt; 와 같은 식이라는 점이다. 또한 결합된 두 연산자는 반드시 공백이 없어야 한다.&lt;/p&gt;

&lt;h2 id=&quot;기타-연산자&quot;&gt;기타 연산자&lt;/h2&gt;

&lt;h3 id=&quot;조건-연산자&quot;&gt;조건 연산자&lt;/h3&gt;

&lt;p&gt;조건 연산자는 조건식, 첫 번째 식, 두 번째 식, 이렇게 세 개의 피연산자를 필요로 하는 &lt;strong&gt;삼항 연산자&lt;/strong&gt; 다. 조건 연사자는 첫 번째 피연산자인 조건식의 평가결과에 따라 다른 결과를 반환한다. 조건의 평가결과가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 면 첫 번째 식이 반환되고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; 면 두 번째 식이 반환된다. 이때 조건 연산자 또한 이항 연산자처럼 첫 번째 식과 두 번째 식의 피연산자 자료형이 다른 경우 산술 변환이 발생한다. 조건 연산자는 아래 이미지와 같이 표현한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/15.png&quot; alt=&quot;조건 연산자&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이외에도 람다 표현식이 등장하며 나온 화살표 연산자( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; )나 참조변수가 참조하고 있는 인스턴스의 타입을 알아볼 때 사용하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;instanceof&lt;/code&gt; 연산자, 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;switch&lt;/code&gt; 제어문에서 사용하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;switch&lt;/code&gt; 연산자( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;yield&lt;/code&gt; )가 있는데 이에 대해선 앞으로 하나씩 더 자세히 알아보고자 한다.&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/whiteship/live-study/issues/3&quot;&gt;3주차 과제: 연산자 · Issue #3 · whiteship/live-study&lt;/a&gt;&lt;/p&gt;</content><author><name>이주</name></author><category term="2기" /><summary type="html">연산자 (Operator)</summary></entry><entry><title type="html">진법과 자바의 변수, 메모리</title><link href="https://week-with-me.github.io/TWIL/1%EA%B8%B0/%EC%A7%84%EB%B2%95%EA%B3%BC-%EC%9E%90%EB%B0%94%EC%9D%98-%EB%B3%80%EC%88%98-%EB%A9%94%EB%AA%A8%EB%A6%AC/" rel="alternate" type="text/html" title="진법과 자바의 변수, 메모리" /><published>2021-07-11T00:00:00+09:00</published><updated>2021-07-11T00:00:00+09:00</updated><id>https://week-with-me.github.io/TWIL/1%EA%B8%B0/%EC%A7%84%EB%B2%95%EA%B3%BC-%EC%9E%90%EB%B0%94%EC%9D%98-%EB%B3%80%EC%88%98-%EB%A9%94%EB%AA%A8%EB%A6%AC</id><content type="html" xml:base="https://week-with-me.github.io/TWIL/1%EA%B8%B0/%EC%A7%84%EB%B2%95%EA%B3%BC-%EC%9E%90%EB%B0%94%EC%9D%98-%EB%B3%80%EC%88%98-%EB%A9%94%EB%AA%A8%EB%A6%AC/">&lt;h2 id=&quot;2진법&quot;&gt;2진법&lt;/h2&gt;

&lt;h3 id=&quot;덧셈&quot;&gt;덧셈&lt;/h3&gt;

&lt;p&gt;우리가 흔히 실생활에서 사용 중인 10진법과 마찬가지로 &lt;strong&gt;오른쪽(LSB__Least Significant Bits)에서 왼쪽(MSB__Most Significat Bits)으로 자릿수에 맞춰서 더해주면 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아래 이미지는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 두 수로 만들 수 있는 &lt;strong&gt;합산 결괏값인 Sum과 그에 대한 버림인 Carry&lt;/strong&gt; 를 표현한 것이다. 이때 나중에 살펴보겠지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 같이 더해서 &lt;strong&gt;Carry가 발생하는 경우를 자릿수가 넘쳐 버려졌기 때문에 오버플로우라 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;여기서 중요한 점은 &lt;strong&gt;Sum은 XOR 게이트, Carry는 AND 게이트&lt;/strong&gt; 를 통해 구할 수 있다는 것이다. XOR 게이트란 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 의 개수가 홀수일 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; , 그 외에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; 를 반환하는 논리 연산을 의미하며 AND 게이트란 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 일 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; , 그 외에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; 를 반환하는 논리 연산을 의미한다. 이처럼 &lt;strong&gt;컴퓨터는 덧셈을 수행할 때 XOR 칩과 AND 칩을 이용하여 Sum과 Carry를 구하게 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/1.jpg&quot; alt=&quot;2진법 덧셈&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;보수&quot;&gt;보수&lt;/h3&gt;

&lt;p&gt;보수는 더했을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; 이 되는 수를 의미한다. 다시 말해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; 의 보수는 곧 더했을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; 이 되어야 하기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; 의 보수는 더해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; 가 되어야 한다는 의미다. 예를 들어 2진수에서 2의 보수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 이 된다는 의미와 같다.&lt;/p&gt;

&lt;p&gt;만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0101&lt;/code&gt; 이라는 10진수로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt; 의 값을 갖는 2진수가 있다고 하자. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0101&lt;/code&gt; 의 2의 보수는 더해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000&lt;/code&gt; 이 나와야 하는 수, 다시 말해 자리올림이 발생해서 크기로 인해 버려져야 하는 수이기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1010&lt;/code&gt; 이 곧 2의 보수가 된다. 이를 10진법으로 나타내면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0101&lt;/code&gt; 의 10진수가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt; 이기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0101&lt;/code&gt; 의 2의 보수인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1010&lt;/code&gt; 의 10진수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-5&lt;/code&gt; 여야 한다.&lt;/p&gt;

&lt;h3 id=&quot;음수-표현&quot;&gt;음수 표현&lt;/h3&gt;

&lt;p&gt;이렇게 보수를 통해서 2진법의 음수를 표현하는 방식을 유추할 수 있다. 우선 아래 이미지를 한 번 살펴보자.&lt;/p&gt;

&lt;p&gt;아래 표와 같이 &lt;strong&gt;MSB(Most Significant Bits)인 가장 왼쪽의 비트를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 일 경우 양수, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 일 경우 음수로 표현&lt;/strong&gt; 하여 나타낼 경우 두 가지 문제점이 발생한다. 하나는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 이 두 번 중복된다는 점이고 그리고 보수를 제대로 표현할 수 없다는 점이다. 예를 들어 10진수로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; 를 나타내는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0010&lt;/code&gt; 값과 MSB를 사용한 음수 표현의 10진수 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-2&lt;/code&gt; 인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1010&lt;/code&gt; 을 더하게 되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1100&lt;/code&gt; 으로 결괏값으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-4&lt;/code&gt; 가 나온다.&lt;/p&gt;

&lt;p&gt;이러한 문제점을 해결하기 위해 등장한 것이 &lt;strong&gt;2의 보수를 사용&lt;/strong&gt; 하는 방법이다. 2의 보수는 &lt;strong&gt;1의 보수를 구한 다음 그 결괏값에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 을 더하여 쉽게 구할 수 있다.&lt;/strong&gt; 1의 보수는 더해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 이 되어야 하는 수를 의미하기 때문에 다시 말해 2진법에서의 1의 보수는 곧 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 으로 바꾸는 걸 의미한다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 의 수를 서로 바꿔 준다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 을 더해주면 쉽게 2진수의 음수 표현을 구할 수 있다. 예를 들어 10진수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;7&lt;/code&gt; 을 의미하는 2진수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0111&lt;/code&gt; 의 음수는 1의 보수를 통해 구한 결괏값인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1000&lt;/code&gt; 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 을 더한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1001&lt;/code&gt; 이 된다. 10진수끼리의 덧셈 또한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 이 되며 진수끼리의 덧셈 또한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0111&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1001&lt;/code&gt; 의 덧셈이기 때문에 버림으로 인해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000&lt;/code&gt; 이 된다는 걸 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2.jpg&quot; alt=&quot;2진법 음수 표현&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;8진법-16진법&quot;&gt;8진법, 16진법&lt;/h2&gt;

&lt;p&gt;컴퓨터에서 2진법으로 값을 표현할 때 64비트 컴퓨터가 레지스터에 값을 표현하려면 자리수가 상당히 길어질 것이다. 따라서 이러한 문제를 보완하기 위해 8진법과 16진법을 사용한다. 8진법의 경우 $0$ 부터 $7$ 까지의 숫자만 있으면 되기 때문에 별다는 기호가 필요하지 않으나 16진법의 경우 $10$ 이부터는 두 자리수이기 때문에 별도의 표현 방식이 필요해서 이를 $A$ 로 표현하여 이후 차례대로 증가하여 최대값인 $15$ 는 $F$ 다.&lt;/p&gt;

&lt;h2 id=&quot;진법-변환&quot;&gt;진법 변환&lt;/h2&gt;

&lt;h3 id=&quot;2진수를-8진수로-변환&quot;&gt;2진수를 8진수로 변환&lt;/h3&gt;

&lt;p&gt;쉽게 2진수를 뒤에서부터 3자리씩 끊어서 그에 해당하는 8진수로 바꾸면 된다. $8$ 이라는 값이 $2^3$ 이기 때문에 3자리씩 끊는다.&lt;/p&gt;

&lt;h3 id=&quot;2진수를-16진수로-변환&quot;&gt;2진수를 16진수로 변환&lt;/h3&gt;

&lt;p&gt;8진수와 유사하게 2진수를 뒤에서부터 4자리씩 끊어서 그에 해당하는 16진수로 바꾸면 된다.  $16$ 이라는 값이 $2^4$ 이기 때문에 4자리씩 끊는다.&lt;/p&gt;

&lt;h1 id=&quot;자바의-변수&quot;&gt;자바의 변수&lt;/h1&gt;

&lt;h2 id=&quot;변수-variable&quot;&gt;변수 (Variable)&lt;/h2&gt;

&lt;h3 id=&quot;정의&quot;&gt;정의&lt;/h3&gt;

&lt;p&gt;변수란, &lt;strong&gt;단 하나의 값을 저장할 수 있는 메모리 공간&lt;/strong&gt; 을 의미한다. 따라서 하나의 변수에는 단 하나의 값을 저장할 수 있기 때문에 &lt;strong&gt;새로운 값을 저장하면 기존의 값은 사라진다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;선언과-초기화&quot;&gt;선언과 초기화&lt;/h3&gt;

&lt;p&gt;아래 이미지를 보면서 이야기하면 쉽다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int a;&lt;/code&gt; 와 같이 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 에 어떤 자료형을 사용할 것인지 말해주는 것이 선언을 의미한다. 그리고 바로 아래 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 3;&lt;/code&gt; 과 같이 실제 값(리터럴)을 할당( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=&lt;/code&gt; ) 할 때 가장 처음 값을 할당해주는 걸 초기화라고 한다. 그리고 보통은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int b = 4;&lt;/code&gt; 와 같이 변수를 선언할 때 초기화를 함께 해준다.&lt;/p&gt;

&lt;p&gt;여기서 유의할 점은 &lt;strong&gt;선언을 통해서 변수 테이블(Symbol Table)에 변수의 이름, 다시 말해 식별자(Identifier)를 지정하고 초기화를 통해 해당 식별자에 값의 주소를 연결&lt;/strong&gt; 해주게 되는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System.out.println(c)&lt;/code&gt; 와 같이 만약 선언하지 않아서 테이블에 존재하지 않는 값을 불러올 경우 해당 변수를 찾을 수 없다는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cannot find symbol error&lt;/code&gt; 가 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/3.png&quot; alt=&quot;변수의 선언과 초기화&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;명명규칙-및-컨벤션-convention&quot;&gt;명명규칙 및 컨벤션 (Convention)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;프로그래밍에서 사용하는 모든 이름을 식별자(Identifier)&lt;/strong&gt; 라고 한다. 이때 식별자는 같은 영역 내에서 서로 구분될 수 있어야 하기 때문에 아래와 같은 규칙을 지켜야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;대소문자가 구분되며 길이에 제한이 없다.&lt;/li&gt;
  &lt;li&gt;예약어(keyword 또는 reserved word)를 사용해서는 안 된다.&lt;/li&gt;
  &lt;li&gt;숫자로 시작해서는 안 된다.&lt;/li&gt;
  &lt;li&gt;특수 문자는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt; 만 가능하다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;또한 권장하는 규칙, 다시 말해 네이밍 컨벤션 또한 아래와 같이 존재한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클래스 이름의 첫 글자는 항상 대문자로 한다. 이때 변수와 메서드 이름의 첫 글자는 항상 소문자로 한다.&lt;/li&gt;
  &lt;li&gt;여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다. ( &lt;strong&gt;카멜 케이스&lt;/strong&gt; )&lt;/li&gt;
  &lt;li&gt;상수의 이름은 모두 대문자로 하며 여러 단어로 이루어진 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt; 를 사용해 구분한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;변수(variable)와 식별자(identifier)를 혼용&lt;/strong&gt; 하는 경우가 많다. 변수는 그 정의에서도 알 수 있듯이 하나의 값, 다시 말해 &lt;strong&gt;데이터를 저장하고 또 새로운 값이 저장되면서 변할 수 있는 것&lt;/strong&gt; 을 의미한다. 반면 식별자는 이러한 데이터를 단어 그대로 식별하는 데 사용하는 이름, 다시 말해 &lt;strong&gt;변수명&lt;/strong&gt; 을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;기타&quot;&gt;기타&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;변수의 스코프(Scope)와 라이프타임(Lifetime)&lt;/strong&gt; 도 매우 중요한 개념이지만 이에 대해서는 아직 객체에 관해 배우지 않았기 때문에 객체와 메서드 개념을 배우는 객체 지향 프로그래밍 챕터에서 다뤄보고자 한다.&lt;/p&gt;

&lt;h1 id=&quot;변수의-타입&quot;&gt;변수의 타입&lt;/h1&gt;

&lt;h2 id=&quot;값의-종류&quot;&gt;값의 종류&lt;/h2&gt;

&lt;p&gt;값의 종류는 크게 문자와 숫자로 나눌 수 있다. 그리고 다시 숫자는 정수와 실수로 구분이 되는데 이를 간단하게 나타내면 아래 이미지와 같다. 이때 자바의 자료형에서는 문자 자료형인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt; , 숫자 자료형 중 정수 자료형인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byte&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;short&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 그리고 실수 자료형인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;double&lt;/code&gt; 이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/4.png&quot; alt=&quot;값의 종류&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;기본형-primitive-type&quot;&gt;기본형 (Primitive Type)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;기본형 변수는 실제 값(data)을 저장한다.&lt;/strong&gt; 이때 유의할 점은 자바의 참조형 변수는 상호 간의 연산이 안 되기 때문에 실제 연산에 사용되는 것은 모두 기본형 변수이다.&lt;/p&gt;

&lt;p&gt;기본형의 경우 아래 이미지와 같이 불변하는 값, 다시 말해 &lt;strong&gt;데이터 영역에 저장되어 있는 상수(리터럴)의 주소를 변수가 가리키게 된다.&lt;/strong&gt; 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abc&lt;/code&gt; 라는 상수 값의 주소인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5004&lt;/code&gt; 를 값으로 가리키게 되는 것이다. 그렇기 때문에 실제로 값을 가리키게-저장하게 되기 때문에 다른 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 를 할당할 경우 똑같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5004&lt;/code&gt; 번의 &lt;strong&gt;주소가 복제&lt;/strong&gt; 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/5.png&quot; alt=&quot;기본형의 메모리 할당 방법&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;논리형--boolean-&quot;&gt;논리형 ( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boolean&lt;/code&gt; )&lt;/h3&gt;

&lt;p&gt;논리형은 기본적으로 참( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; )과 거짓( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; )만 다루면 되기 때문에 1 비트의 크기면 충분하지만 자바에서 데이터를 다루는 최소단위가 바이트이기 때문에 크기가 1 바이트로 지정됐다. 이때 기본값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; 다. 주의할 점은 자바에서는 대소문자를 구별하기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TRUE&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 모두 다른 값을 의미한다는 점이다.&lt;/p&gt;

&lt;h3 id=&quot;문자형--char-&quot;&gt;문자형 ( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt; )&lt;/h3&gt;

&lt;p&gt;문자형의 크기는 2 바이트다. 따옴표( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;''&lt;/code&gt; )를 사용하여 단 하나의 문자만을 저장한다. 이때 실제로 변수에 저장되는 값은 문자가 아닌 문자의 유니코드(정수)가 저장된다.&lt;/p&gt;

&lt;p&gt;아래 코드 예시를 한 번 살펴보자. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt; 자료형을 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;65&lt;/code&gt; 를 저장했음에도 불구하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;println()&lt;/code&gt; 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ch&lt;/code&gt; 변수의 자료형이 문자형이기 때문에 자동으로 유니코드에 의해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 라는 결괏값을 출력해줬다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/6.png&quot; alt=&quot;문자형&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;잠깐! &lt;strong&gt;유니코드(Unicode)&lt;/strong&gt; 란 무엇일까?&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;컴퓨터는 결국 이진법으로만, 다시 말해 숫자로만 모든 것을 이해하기 때문에 문자 자체도 숫자로 표현해줘야 한다.&lt;/strong&gt; 이때 각 문자에 알맞은 숫자를 정해서 어떤 문자를 사용하면 이를 자동으로 정해진 숫자로 변환하며 컴퓨터가 이해할 수 있게 해주는 표가 바로 유니코드다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;정수형--byte--short--int--long-&quot;&gt;정수형 ( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byte&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;short&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; )&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byte&lt;/code&gt; : 1 바이트의 크기를 가진다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;short&lt;/code&gt; : 2 바이트의 크기를 가진다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; : 4 바이트의 크기를 가진다. &lt;strong&gt;기본 자료형(default data type)&lt;/strong&gt; 이다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; : 8 바이트의 크기를 가진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모든 정수형은 부호가 있기 때문에 &lt;strong&gt;가장 왼쪽의 첫 번째 비트를 부호 비트(sign bit)로 사용&lt;/strong&gt; 하고 나머지는 값을 표현하는 데 사용한다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; 비트로 표현할 수 있는 부호있는 정수의 범위는 곧  $-2^{N-1}$  ~  $2^{N-1} - 1$ 까지다. 따라서 1 바이트의 경우 8 비트와 같기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byte&lt;/code&gt; 자료형에 저장할 수 있는 수의 범위는 곧 $-128$ ~ $127$ 까지다.&lt;/p&gt;

&lt;p&gt;이때 유의할 점은 &lt;strong&gt;JVM의 피연산자 스택(operand stack)이 피연산자를 4 바이트 단위로 저장&lt;/strong&gt; 한다는 점이다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byte&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;short&lt;/code&gt; 자료형의 경우 필수적으로 저장공간을 절약해야 할 때 그 크기에 맞춰 사용하고 일반적인 경우에는 4 바이트보다 작은 자료형의 값을 계산할 때 이를 4 바이트로 변환해서 연산이 수행되기 때문에 오히려 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형을 사용하는 게 훨씬 효율적이다. 더욱이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byte&lt;/code&gt; 자료형의 경우 앞선 예시에서 알 수 있듯이 범위가 매우 작기 때문에 연산의 결괏값이 예상하지 못한, &lt;strong&gt;오버플로우가 발생&lt;/strong&gt; 할 수 있다.&lt;/p&gt;

&lt;p&gt;아래 이미지를 통해 오버플로우에 대해 간단하게 이해할 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byte&lt;/code&gt; 자료형의 최대값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127&lt;/code&gt; 이고 최소값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-128&lt;/code&gt; 이다. 그런데 각각 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 을 더하고 빼서 범위를 넘길 경우 아래와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;128&lt;/code&gt; 이 아닌 최소값 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-128&lt;/code&gt; 로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-129&lt;/code&gt; 가 아닌 최대값 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127&lt;/code&gt; 로 변한 것을 확인할 수 있다. 이처럼 &lt;strong&gt;변수가 표현할 수 있는 범위를 넘어선 것&lt;/strong&gt; 을 오버플로우라고 한다. 이때  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(byte)&lt;/code&gt; 라는 표현 방식은 형변환을 의미한다. 이에 관해서는 이따가 형변환 부분에서 더 자세히 살펴보고자 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/7.png&quot; alt=&quot;오버플로우&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;실수형--float--double-&quot;&gt;실수형 ( &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;double&lt;/code&gt; )&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt; : 4 바이트의 크기를 가진다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;double&lt;/code&gt; : 8 바이트의 크기를 가진다. &lt;strong&gt;기본 자료형(default data type)&lt;/strong&gt; 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정수형의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형과 실수형의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt; 자료형은 같은 4 바이트의 크기를 갖지만 실수형인 float 자료형이 정수형인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형보다 훨씬 더 넓은 범위의 숫자를 표현할 수 있다. 이는 어떻게 가능한 것일까? 바로 실수형은 부동 소수점(floating point) 방식으로 값을 저장하기 때문이다.&lt;/p&gt;

&lt;p&gt;부동 소수점이란 값을 &lt;strong&gt;부호(Sign)&lt;/strong&gt; , &lt;strong&gt;지수(Exponent)&lt;/strong&gt; , &lt;strong&gt;가수(Mantissa)&lt;/strong&gt; , 이렇게 세 부분으로 나누어 표현하는 방식을 의미한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;부호: 부호 비트를 의미하며 1 비트의 크기를 가진다. 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 이면 양수를, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 이면 음수를 의미한다. 정수형의 경우 부호를 바꾸기 위해서는 2의 보수법을 사용해야 하는데 실수형에서는 그렇지 않기 때문에 단순히 해당 부호의 값을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 로 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 으로 변경해주기만 하면 된다.&lt;/li&gt;
  &lt;li&gt;지수: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt; 자료형의 경우 8 비트의 크기를 가진다. 부호있는 정수로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt; 의 경우 $-127$ 부터 $128$ 까지 총 $2^8$ 개 만큼의 값을 저장할 수 있게 된다.&lt;/li&gt;
  &lt;li&gt;가수: 실제 값을 저장하는 부분으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt; 자료형의 경우 총 32 비트 중 부호와 지수를 뺀 나머지 23 비트의 크기를 가진다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt; 자료형은 2진수 23자리를 저장할 수 있게 되는데 이는 곧 10진수로 표현했을 때 7자리 정도의 숫자이기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt; 자료형의 정밀도는 7자리가 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어 $0.2 * 2^-1$ 과 같은 방식으로 부동 소수점을 표현할 수 있는데 이때 $0.2$ 가 곧 가수이고 컴퓨터는 이진법으로 이루어져있기 때문에 밑수가 $2$ 이면서 지수가 $-1$ 이 된다. 이를 정규화하게 되면 결국 첫 번째 자리의 숫자는 항상 $1$ 이 되고 결국 이러한 특징으로 인해 컴퓨터의 부동 소수점 표현은 주로 $1.m * 2^n$ 과 같다.&lt;/p&gt;

&lt;p&gt;유의할 점은 이러한 지수 표현 방식으로 인해 아무리 값을 작게 해도 $0$ 을 표현할 수 없는 등의 &lt;strong&gt;정밀도에 대한 오류가 발생&lt;/strong&gt; 하게 된다. 아래 코드 예시를 살펴보자. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.1&lt;/code&gt; 을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10000&lt;/code&gt; 번 더했기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1001&lt;/code&gt; 이 나와야 될 것으로 생각하지만 실제 결괏값은 이상한 더미 데이터가 붙게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/8.png&quot; alt=&quot;실수형의 표현 오류&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;잠깐! &lt;strong&gt;정규화&lt;/strong&gt; 란 무엇일까?&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;정규화는 밑수보다 작은 한 자리까지 가수로 표현되는 것&lt;/strong&gt; 을 의미하는 데 앞서 살펴봤듯이 컴퓨터에서는 이진법을 사용하기 때문에 밑수가 $2$ 라서 결국 가수가 $2$ 보다 작은 한 자리, 다시 말해 $1$ 이 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;잠깐! &lt;strong&gt;실수형에서는 오버플로우가 발생&lt;/strong&gt; 하지 않을까?&lt;/p&gt;

  &lt;p&gt;실수형에서도 물론 오버플로우가 존재한다. 다만 이때는 정수형과 달리 &lt;strong&gt;변수의 값이 무한대(Infinity)&lt;/strong&gt; 가 된다. 그리고 정수형에는 없는 &lt;strong&gt;언더플로우(underflow)가 존재하는데 실수형으로 표현할 수 없는 작은 값&lt;/strong&gt; 을 의미하며 이때 변수의 값은 $0$ 이 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;결론&quot;&gt;결론&lt;/h3&gt;

&lt;p&gt;기본형의 크기와 표현할 수 있는 최소값부터 최대값까지를 간단하게 나타내면 아래 이미지와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/9.png&quot; alt=&quot;기본형 크기와 표현할 수 있는 값의 범위&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참조형-reference-type&quot;&gt;참조형 (Reference Type)&lt;/h2&gt;

&lt;p&gt;참조형 변수는 어떤 값이 저장되어 있는 &lt;strong&gt;주소(memory address)를 값으로 갖는다.&lt;/strong&gt; 이는 다시 말하면 객체의 주소를 저장한다는 의미로 기본형을 제외한 나머지 다른 모든 타입이 참조형에 해당한다. 참조형 변수를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스 이름이 곧 타입이 된다. 이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt; 라는 연산자와 함께 생성자(Constructor)를 사용한다. 그리고 그 &lt;strong&gt;결괏값으로 생성된 객체의 주소가 참조변수에 저장&lt;/strong&gt; 되는 것이다.&lt;/p&gt;

&lt;p&gt;아래 이미지를 통해 간단하게 살펴보자. 참조형 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj1&lt;/code&gt; 의 값이 객체 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;501&lt;/code&gt; 를 가리키고 있고 해당 객체의 값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;7103&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;7104&lt;/code&gt; 를 가리키고 있는 걸 알 수 있다. 그리고 실질적인 값은 결국 7103 의 주소에 저장되어 있는 변수 a 가 저장하고 있는 값인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5003&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;7104&lt;/code&gt; 의 주소에 저장되어 있는 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 가 저장하고 있는 값인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5004&lt;/code&gt; 가 된다.&lt;/p&gt;

&lt;p&gt;이처럼 결괏값으로 생성된 객체의 주소인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5001&lt;/code&gt; 의 실질적인 값인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;7103&lt;/code&gt; 고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;7104&lt;/code&gt; 가 참조변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj1&lt;/code&gt; 에 의해 참조되는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/10.png&quot; alt=&quot;참조형 데이터의 할당&quot; /&gt;&lt;/p&gt;

&lt;p&gt;결론적으로 &lt;strong&gt;기본형의 경우 할당과 연산 때 값을 복제&lt;/strong&gt; 하고 &lt;strong&gt;참조형의 경우 할당과 연산 때 값을 참조&lt;/strong&gt; 한다는 차이점이 존재하는데 이를 통해 참조형 중의 경우 &lt;strong&gt;깊은 복사(Deep Copy)와 얕은 복사(Shallow Copy)&lt;/strong&gt; 개념이 연관된다. 이에 관해서는 배열 챕터와 객체 지향 프로그래밍 챕터에서 더 자세하게 다뤄보고자 한다.&lt;/p&gt;

&lt;h3 id=&quot;메모리와-데이터&quot;&gt;메모리와 데이터&lt;/h3&gt;

&lt;p&gt;컴퓨터는 모든 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 의 이진법으로 기억한다. 이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 로만 표현할 수 있는 하나의 메모리 조각을 &lt;strong&gt;비트(bit)&lt;/strong&gt; 라고 하는데 &lt;strong&gt;메모리는 이러한 비트들의 집합&lt;/strong&gt; 으로 구성되며 각 &lt;strong&gt;비트는 고유한 식별자(unique indentifier)를 통해 위치를 확인&lt;/strong&gt; 할 수 있다.&lt;/p&gt;

&lt;p&gt;이때 비트를 묶어서 표현할 경우 검색 시간을 줄일 수 있는 것은 물론 표현할 수 있는 데이터의 개수도 늘어난다. 하지만 동시에 낭비되는 비트가 생기기 때문에 이러한 고민을 통해 등장한 것이 &lt;strong&gt;바이트(byte)&lt;/strong&gt; 다. 1바이트는 8개의 비트로 구성돼 있다.&lt;/p&gt;

&lt;p&gt;비트가 고유한 식별자를 가지고 있는 것처럼 바이트 또한 시작하는 비트의 식별자로 위치를 파악할 수 있다. 이처럼 바이트의 시작하는 비트가 곧 메모리 주소를 의미한다. &lt;strong&gt;자바에서는 메모리에 1 바이트 단위로 일련번호가 붙어있는데 이 번호가 곧 메모리 주소&lt;/strong&gt; 다. 이때 객체의 주소는 객체가 저장된 메모리 주소를 의미한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;잠깐! &lt;strong&gt;자료형(Data Type)&lt;/strong&gt; 과 &lt;strong&gt;타입(Type)&lt;/strong&gt; 의 차이가 뭔가요?&lt;/p&gt;

  &lt;p&gt;기본적으로 타입이 자료형을 포함하는 보다 넓은 의미다. &lt;strong&gt;기본형의 경우 값(data)의 종류에 따라 구분이 되기 때문에 기본형의 종류를 이야기할 때는 자료형(data type)&lt;/strong&gt; 이라는 용어를 사용하지만 &lt;strong&gt;참조형의 경우 객체의 주소를 저장하기 때문에 값이 아닌 종류(type)로 구별해서 타입(type)&lt;/strong&gt; 이라는 용어를 쓴다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;기본값&quot;&gt;기본값&lt;/h2&gt;

&lt;p&gt;자바의 경우 자료형에 따른 &lt;strong&gt;변수의 기본값&lt;/strong&gt; 은 아래 이미지 처럼 존재한다. 우선 이에 대해서 알기 위해서는 &lt;strong&gt;C언어에서의 쓰레기 값(Garbage Value)&lt;/strong&gt; 에 대해서 알고 있으면 좋다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/11.jpg&quot; alt=&quot;자료형의 기본값&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;쓰레기-값-garbage-value&quot;&gt;쓰레기 값 (Garbage Value)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;쓰레기 값이란 메모리에 어떤 변수를 선언하여 어떤 위치에 할당 시키고 그 변수에 어떤 값(데이터)을 할당 할 때 만약 값을 할당하지 않으면 무의미한 아무 값으로 초기화 되는 걸 의미&lt;/strong&gt; 한다. C언어 코드를 통해 이를 살펴보면 아래 이미지와 같다.&lt;/p&gt;

&lt;p&gt;선언만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 에 값이 초기화 해주지 않았는데 임의의 값 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;228601893&lt;/code&gt; 이 할당 됐다. 반대로 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id2&lt;/code&gt; 의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 을 초기화해주자 알맞은 값인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; 이 결괏값으로 출력된 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/12.png&quot; alt=&quot;C언어 쓰레기 값&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이처럼 C언어에서의 변수는 선언과 동시에 초기화를 해줘야 예상하지 못했던 결괏값을 사용하게 되는 오류를 방지할 수 있게 되는데 자바의 경우 지역 변수에서는 선언만 했을 경우, 다시 말해 &lt;strong&gt;초기화하지 않은-값을 할당하지 않은 변수의 경우 스코프 내에서 사용할 수 없게 컴파일러 오류를 반환&lt;/strong&gt; 한다.&lt;/p&gt;

&lt;p&gt;그렇다면 변수의 기본값이 왜 존재하는 걸까? 이는 멤버 변수와 같은 글로벌 변수를 위해 존재한다. 아래 이미지와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Test&lt;/code&gt; 라는 객체에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;testNum&lt;/code&gt; 이라는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형을 선언만 했을 경우 이를 사용하게 되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 이라는 결괏값을 출력하는 것을 확인할 수 있다. 반대로 지역 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tesNum2&lt;/code&gt; 은 선언만 했을 때는 따로 컴파일 오류를 발생시키지 않지만 이를 사용하려고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;println()&lt;/code&gt; 을 통해 출력을 시도했을 때는 초기화되지 않았다는 컴파일 오류를 반환하는 것을 알 수 있다. 조금 더 자세한 내용은 변수의 스코프(Scope)와 생명주기(Lifetime), 그리고 객체 지향 프로그래밍 때 더 자세히 다뤄보고자 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/13.png&quot; alt=&quot;기본값 테스트&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;상수와-리터럴&quot;&gt;상수와 리터럴&lt;/h2&gt;

&lt;h3 id=&quot;상수-constant&quot;&gt;상수 (Constant)&lt;/h3&gt;

&lt;p&gt;상수는 변수와 마찬가지로 값을 저장할 수 있는 공간이지만 변수와 달리 한 번 값을 저장하면 &lt;strong&gt;다른 값으로 변경할 수 없다.&lt;/strong&gt; 변수와 선언하는 방법이 동일하지만 타입 앞에 키워드 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;final&lt;/code&gt; 을 붙여줘야 한다.&lt;/p&gt;

&lt;h3 id=&quot;리터럴-literal&quot;&gt;리터럴 (Literal)&lt;/h3&gt;

&lt;p&gt;우리가 흔히 사용하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;123&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;ABC&quot;&lt;/code&gt; 와 같은 값들 또한 상수이다. 하지만 프로그래밍에서 상수와 이러한 값을 구별하기 위해 기존에 우리가 아는 상수를 리터럴이라는 용어로 부르기로 했다. 따라서 리터럴은 그 자체로 값을 의미하는 것이라 생각하면 된다. 변수, 상수, 리터럴을 구분하면 간단하게 아래 이미지와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/14.jpg&quot; alt=&quot;변수, 상수, 리터럴 구분&quot; /&gt;&lt;/p&gt;

&lt;p&gt;앞서 실수 자료형의 기본 자료형은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;double&lt;/code&gt; 이기 때문에 실수를 표현할 때는 리터럴에 접미사로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt; 를 붙여줘야 한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;double&lt;/code&gt; 자료형의 경우 실수형의 기본 자료형이기는 하지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt; 과 마찬가지로 구별을 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt; 를 접미사로 붙여줘야 하며 정수형 중에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 자료형을 사용할 때 접미사로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;L&lt;/code&gt; 을 사용해야 한다. 그렇지 않으면 정수형의 기본 자료형은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 이기 때문에 오류가 발생한다.&lt;/p&gt;

&lt;p&gt;아래 이미지를 통해 간단하게 이를 알 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float&lt;/code&gt; 자료형에 리터럴 접미사를 사용하지 않아서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;incompatible types&lt;/code&gt; 라는 오류가 발생한 것을 확인할 수 있다. 아래 리터럴 접미사 F 를 사용한 경우 정상적으로 오류 없이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3.14&lt;/code&gt; 라는 결괏값을 출력한 걸 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/15.png&quot; alt=&quot;리터럴&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JDK1.7부터는 정수형 리터럴 중간에 구분자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt; 를 넣을 수 있게 되어서 큰 숫자를 편하게 읽을 수 있게 됐다. 예를 들어 기존 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;100000&lt;/code&gt; 으로 작성해야 했던 값은 이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;100_000&lt;/code&gt; 와 같은 형태로 쓸 수 있는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;상수-풀-constant-pool&quot;&gt;상수 풀 (Constant Pool)&lt;/h3&gt;

&lt;p&gt;이전 JVM에서 메모리 영역에 대해 이야기하며 프로그램을 실행할 때 기본적으로 운영체제가 메모리에 프로그램을 할당하는 공간 중 데이터 영역(Data Area)에 관해 이야기한 적이 있다. &lt;strong&gt;전역 변수와 정적 변수가 저장되는 공간&lt;/strong&gt; 이라고도 언급했었는데 &lt;strong&gt;상수와 리터럴&lt;/strong&gt; 이 바로 이 영역에 저장된다. &lt;strong&gt;프로그램이 실행될 때 메모리가 로드(Load)되며 프로그램의 실행이 끝나고 언메모리 될 때 해제&lt;/strong&gt; 된다. &lt;strong&gt;데이터 영역 또는 상수 풀이라고 부른다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;타입-변환&quot;&gt;타입 변환&lt;/h2&gt;

&lt;p&gt;변수 또는 상수의 타입을 다른 타입으로 변환하는 것을 의미한다. 이때 &lt;strong&gt;기본형의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boolean&lt;/code&gt; 자료형을 제외한 나머지 자료형끼리 서로 형변환이 가능&lt;/strong&gt; 하다. 그리고 &lt;strong&gt;기본형과 참조형 간의 형변환은 불가능&lt;/strong&gt; 하다.&lt;/p&gt;

&lt;h3 id=&quot;자동-형변환-type-promotion&quot;&gt;자동 형변환 (Type Promotion)&lt;/h3&gt;

&lt;p&gt;묵시적 형변환이라고도 한다. 바이트 &lt;strong&gt;크기가 작은 자료형에서 더 큰 자료형으로&lt;/strong&gt; 의 형변환으로 자동으로 형변환이 이루어진다.&lt;/p&gt;

&lt;h3 id=&quot;강제-형변환-type-casting&quot;&gt;강제 형변환 (Type Casting)&lt;/h3&gt;

&lt;p&gt;명시적 형변환이라고도 한다. 바이트 &lt;strong&gt;크기가 더 큰 자료형을 작은 자료형으로&lt;/strong&gt; 형변환하려는 시도인데 강제로 형변환을 수행하기 때문에 프로그래머가 이에 대한 &lt;strong&gt;손실이 발생&lt;/strong&gt; 해도 그것을 감수해야한다.&lt;/p&gt;

&lt;h3 id=&quot;기타-1&quot;&gt;기타&lt;/h3&gt;

&lt;p&gt;우리는 앞서 &lt;strong&gt;JVM의 피연산자 스택이 피연산자를 4 바이트 단위로 저장&lt;/strong&gt; 하기 때문에 이보다 작은 자료형인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byte&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;short&lt;/code&gt; 의 값을 계산할 때 해당 자료형들을 4 바이트로 변환한다고 배웠다. 앞서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byte&lt;/code&gt; 자료형의 오버플로우 예시로 살펴 본 코드를 통해 형변환의 두 종류에 대해 다시 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byteMax + 1&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byteMin - 1&lt;/code&gt; 연산을 수행할 경우 4 바이트 단위로 저장 돼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byteMax&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byteMin&lt;/code&gt; 값이 4 바이트라서 오버플로우가 발생하지 않고 각각 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;128&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-129&lt;/code&gt; 라는 결괏값이 출력된다. 이렇게 작은 크기의 자료형이 자연스럽게 큰 자료형으로 형변환이 발생하는 걸 자동 형변환, 타입 프로모션이라 하며 반대로 오버플로우 상황을 연출하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 자료형 결괏값 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;128&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-129&lt;/code&gt; 를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(byte)&lt;/code&gt; 와 같은 형태로 형변환 한 것을 강제 형변환, 타입 캐스팅이라 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/16.png&quot; alt=&quot;형변환&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;타입-추론-type-inference&quot;&gt;타입 추론 (Type Inference)&lt;/h2&gt;

&lt;p&gt;기존 &lt;strong&gt;스크립트 언어에서 가능했던 타입 추론이 컴파일러 언어인 자바 버전 10 이상부터 자바에서도 가능&lt;/strong&gt; 해졌다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var&lt;/code&gt; 라는 키워드를 사용하여 &lt;strong&gt;초기화 된 값의 타입을 추론하여 변수의 자료형을 결정&lt;/strong&gt; 할 수 있는 기능이다. 이때 유의할 점은 초기화를 하지 않으면, 다시 말해 &lt;strong&gt;변수에 값을 할당하지 않으면 오류가 발생&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;앞서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;println()&lt;/code&gt; 은 문자형 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt; 자료형을 값으로 받을 경우 정수가 입력 됐을 때 유니코드에 의해 해당하는 문자를 반환한다는 것을 알 수 있었다. 아래 이미지를 통해 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt; 에 초기화 된 값이 정수형 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10&lt;/code&gt; 이기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt; 의 자료형이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 가 됐다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 라는 값을 다시 입력하더라도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char&lt;/code&gt; 자료형 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt; 처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 가 출력되는 것이 아니라 int 자료형 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;j&lt;/code&gt; 처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;65&lt;/code&gt; 가 출력된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/17.png&quot; alt=&quot;타입 추론&quot; /&gt;&lt;/p&gt;</content><author><name>이주</name></author><category term="1기" /><summary type="html">2진법</summary></entry><entry><title type="html">[CS] 객체 지향 기법</title><link href="https://week-with-me.github.io/TWIL/1%EA%B8%B0/CS-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EA%B8%B0%EB%B2%95/" rel="alternate" type="text/html" title="[CS] 객체 지향 기법" /><published>2021-07-11T00:00:00+09:00</published><updated>2021-07-11T00:00:00+09:00</updated><id>https://week-with-me.github.io/TWIL/1%EA%B8%B0/CS-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EA%B8%B0%EB%B2%95</id><content type="html" xml:base="https://week-with-me.github.io/TWIL/1%EA%B8%B0/CS-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EA%B8%B0%EB%B2%95/">&lt;h1 id=&quot;-개요&quot;&gt;📌 개요&lt;/h1&gt;

&lt;p&gt;현실의 개체(Entity)를 하나의 객체(Object)로 만들어 소프트웨어를 개발할 때 객체들을 이용해 프로그램을 작성할 수 있도록 하는 기법&lt;/p&gt;

&lt;h1 id=&quot;-장점&quot;&gt;📌 장점&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;재 사용성, 확장성 -&amp;gt; 개발 기간 단축, 유지 보수 쉬움&lt;/li&gt;
  &lt;li&gt;복잡한 구조를 단계적, 계층적으로 표현&lt;/li&gt;
  &lt;li&gt;데이터 병렬 처리&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;-구성요소&quot;&gt;📌 구성요소&lt;/h1&gt;

&lt;h2 id=&quot;1-객체object&quot;&gt;1. 객체(Object)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터와 데이터를 처리하는 함수를 캡슐화한 소프트웨어 모듈&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;데이터&lt;/strong&gt; : 객체 정보, 속성, 상태 (속성, 상태, 변수, 상수, 자료 구조 라고도 함)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;함수&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;객체가 수행하는 기능, 객체가 갖는 데이터 (속성, 상태)를 처리하는 알고리즘&lt;/li&gt;
      &lt;li&gt;객체의 상태를 참조, 변경하는 수단이 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-클래스class&quot;&gt;2. 클래스(Class)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;공통된 속성, 연산을 갖는 객체들의 집합&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Instance&lt;/strong&gt; : 클래스에 속한 각각의 객체&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;최상위 class&lt;/strong&gt;: 상위 클래스를 갖지 않는 class&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Superclass&lt;/strong&gt; : 특정 클래스의 상위 class&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Subclass&lt;/strong&gt; : 특정 클래스의 하위 class&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-메시지message&quot;&gt;3. 메시지(Message)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;객체들 간 상호작용을 하기 위한 수단&lt;/li&gt;
  &lt;li&gt;객체 이름, 메소드 이름, 인자로 구성&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;-특징&quot;&gt;📌 특징&lt;/h1&gt;

&lt;h2 id=&quot;-캡슐화encapsulation&quot;&gt;◾ 캡슐화(Encapsulation)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;의미: 데이터와 함수를 하나로 묶음&lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;재사용성 증가, 오류 파급 효과 감소&lt;/li&gt;
      &lt;li&gt;인터페이스가 단순해짐, 객체 간 결합도가 낮아짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-정보-은닉information-hiding&quot;&gt;◾ 정보 은닉(Information hiding)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;다른 객체에게 자신의 정보를 숨기고 자신의 연산 만을 통해 접근&lt;/li&gt;
  &lt;li&gt;다른 객체에게 주는 영향을 감소 시킴&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-추상화abstraction&quot;&gt;◾ 추상화(Abstraction)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;불필요한 부분을 생략하고 중요한 것에만 중점을 두어 모델화&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-상속성inheritance&quot;&gt;◾ 상속성(Inheritance)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받음&lt;/li&gt;
  &lt;li&gt;상위 클래스에 정의된 속성을 재정의 하지 않아도 된다.&lt;/li&gt;
  &lt;li&gt;새로운 속성과 연산을 추가하여 사용 가능&lt;/li&gt;
  &lt;li&gt;다중 상속성(Multiple Inheritance) : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 상속&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-다형성polymorphism&quot;&gt;◾ 다형성(Polymorphism)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;같은 함수, 기능에 대해 다른 정의를 통해 각 클래스가 다른 행동을 할 수 있게 해줌&lt;/li&gt;
  &lt;li&gt;Overloading : 같은 이름을 가진 함수지만 인자가 달라 각기 다른 인자에 따라 함수를 선택해 수행&lt;/li&gt;
  &lt;li&gt;Overriding : 상위 클래스로부터 상속 받은 함수들을 다르게 구현하여 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;-생명-주기&quot;&gt;📌 생명 주기&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;계획 및 분석 → 설계 → 구현 → 테스트 및 검증&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-계획-및-분석-객체-지향-분석-ooa&quot;&gt;◾ 계획 및 분석 (객체 지향 분석, OOA)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;사용자의 요구 사항을 분석하여 클래스, 속성, 연산 등을 정의하여 모델링하는 작업&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-설계-객체-지향-설계-ood&quot;&gt;◾ 설계 (객체 지향 설계, OOD)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;분석을 통해 생성한 모델을 설계 모델로 변환하는 작업&lt;/li&gt;
  &lt;li&gt;설계: 문제 정의 → 요구 명세화 → 객체 연산자 정의 → 객체 인터페이스 결정 → 객체 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-구현-객체-지향-프로그래밍-oop&quot;&gt;◾ 구현 (객체 지향 프로그래밍, OOP)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;객체라는 단위를 중심으로 프로그램을 개발하는 작업&lt;/li&gt;
  &lt;li&gt;유지 보수가 쉽고 재사용 가능&lt;/li&gt;
  &lt;li&gt;확장성 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-테스트-및-검증&quot;&gt;◾ 테스트 및 검증&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;클래스 테스트 : 캡슐화된 클래스나 객체를 검사하는 과정&lt;/li&gt;
  &lt;li&gt;통합 테스트 : 객체를 결합해 프로그램을 완성시키는 과정에서의 테스트
→ thread 기반 테스트 : 각각의 thread 가 개별적으로 테스트
→ 사용 기반 테스트 : 독립 클래스를 테스트한 후, 종속 클래스를 테스트&lt;/li&gt;
  &lt;li&gt;확인 테스트 : 사용자 요구 사항에 대한 만족 테스트&lt;/li&gt;
  &lt;li&gt;시스템 테스트 : 모든 요소들이 올바른 기능을 수행하는지 테스트&lt;/li&gt;
&lt;/ul&gt;</content><author><name>정선미</name></author><category term="1기" /><summary type="html">📌 개요</summary></entry><entry><title type="html">오리엔테이션 및 Git 사용법</title><link href="https://week-with-me.github.io/TWIL/1%EA%B8%B0/%EC%98%A4%EB%A6%AC%EC%97%94%ED%85%8C%EC%9D%B4%EC%85%98-%EB%B0%8F-Git-%EC%82%AC%EC%9A%A9%EB%B2%95/" rel="alternate" type="text/html" title="오리엔테이션 및 Git 사용법" /><published>2021-07-04T00:00:00+09:00</published><updated>2021-07-04T00:00:00+09:00</updated><id>https://week-with-me.github.io/TWIL/1%EA%B8%B0/%EC%98%A4%EB%A6%AC%EC%97%94%ED%85%8C%EC%9D%B4%EC%85%98-%EB%B0%8F-Git-%EC%82%AC%EC%9A%A9%EB%B2%95</id><content type="html" xml:base="https://week-with-me.github.io/TWIL/1%EA%B8%B0/%EC%98%A4%EB%A6%AC%EC%97%94%ED%85%8C%EC%9D%B4%EC%85%98-%EB%B0%8F-Git-%EC%82%AC%EC%9A%A9%EB%B2%95/">&lt;h3 id=&quot;오리엔테이션&quot;&gt;오리엔테이션&lt;/h3&gt;
&lt;h4 id=&quot;목적&quot;&gt;목적&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;TWIL(This Week I Learned)&lt;/strong&gt; 의 목적은 메인 &lt;a href=&quot;https://github.com/week-with-me/TWIL/blob/main/README.md&quot;&gt;README.md&lt;/a&gt;에서 확인하실 수 있는 것처럼 마치 소셜 네트워크 서비스를 이용하듯 각자가 공부한 내용을 쉽고 편하게 공유하는 데 있습니다. 따라서 본인이 글을 쓰기로 결정한 주제에 대해 깊이 있게 조사하고 공부하는 것은 물론 이를 TWIL 멤버를 비롯한 다른 누가 읽더라도 알기 쉽도록 적는 게 목표입니다. 물론 개인적인 생각에는 알기 쉽게 풀어내는 과정에서 자연스레 본인이 몰랐던 개념들을 포함하여 해당 주제를 깊게 공부할 수밖에 없다고 생각합니다&lt;/p&gt;

&lt;h4 id=&quot;규칙&quot;&gt;규칙&lt;/h4&gt;
&lt;p&gt;모든 커뮤니티-스터디와 마찬가지로 TWIL 또한 규칙이 있습니다. 상호 간에 아는 지식을 전달하는 목적보다도 함께 꾸준하게 공부하며 동기부여를 위한 목적이 더 크기에 다른 커뮤니티와 마찬가지로 상호 간에 &lt;strong&gt;-님&lt;/strong&gt; 과 같은 호칭을 붙여 예의를 지켜주세요!&lt;/p&gt;

&lt;p&gt;공부한 내용을 공유할 때도 깔끔하고 구조적인 프로젝트 관리를 위해 몇 가지 규칙이 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0417taehyun&lt;/code&gt; 과 같이 본인의 깃헙 계정으로 브랜치를 만들어 공부한 내용을 작성한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[ 이태현 ] 오리엔테이션 및 Git 사용법&lt;/code&gt; 과 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[ ]&lt;/code&gt; 내의 실명과 그 뒤에 학습한 내용의 제목을 적어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commit&lt;/code&gt; 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.DS_Store&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.vscode&lt;/code&gt; 등과 같이 불필요한 파일 및 폴더가 올라가지는 않았는지 확인하고 만약 함께 올라갔다면 삭제한다.&lt;/li&gt;
  &lt;li&gt;각 주차별 본인의 이름으로 된 폴더를 만들고 내부에 글을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;md&lt;/code&gt; 파일로 작성한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;아래는 혹시 &lt;strong&gt;깃(Git)&lt;/strong&gt; 과 &lt;strong&gt;깃헙(GitHub)&lt;/strong&gt; 이 아직 익숙하지 않은 분들을 위한 간단한 설명입니다.&lt;/p&gt;

&lt;h3 id=&quot;git-사용법&quot;&gt;Git 사용법&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;이미 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commit&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;branch&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pull request&lt;/code&gt; 등의 개념을 아시는 분은 넘겨도 무관한 내용들입니다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;개요&quot;&gt;개요&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;깃(Git)&lt;/strong&gt; 과 &lt;strong&gt;깃헙(GitHub)&lt;/strong&gt; 에 관해 설명하는 건 내용이 길어질 것 같아 생략하겠습니다. 아래 내용들은 깔끔하고 구조화 된 프로젝트 진행을 위해 결정된 커밋과 브랜치 양식에 관해 어떤 개념인지 모르는 분들을 위한, &lt;strong&gt;CLI 터미널 명령어&lt;/strong&gt; 를 통한 간단한 설명입니다. 더 자세한 내용들은 &lt;a href=&quot;https://www.youtube.com/watch?v=hFJZwOfme6w&amp;amp;list=PLuHgQVnccGMA8iwZwrGyNXCGy2LAAsTXk&quot;&gt;생활코딩 깃과 깃헙 강의&lt;/a&gt;를 추천해드립니다.&lt;/p&gt;

&lt;h4 id=&quot;git-clone-명령어&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git clone&lt;/code&gt; 명령어&lt;/h4&gt;
&lt;p&gt;우선 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TWIL&lt;/code&gt; 리무트 레포지토리를 본인의 로컬 환경으로 옮겨야 합니다. 이를 조금 더 쉽게 풀어 설명하자면 &lt;strong&gt;깃헙이라는 서비스&lt;/strong&gt; 에 소스 코드들이 정리되어 올라가 있기 때문에 해당 소스 코드와 파일-폴더들이 담겨있는 일종의 공간을 &lt;strong&gt;리무트 레포지토리, 한글로는 원격 저장소&lt;/strong&gt; 라고 합니다. 이를 삼성 노트북, LG 노트북과 같이 &lt;strong&gt;본인이 프로그래밍하는 공간&lt;/strong&gt; 으로 옮겨야 우리가 동일한 공간에 작업을 하여 각자의 작업 내용을 합칠 수 있게 되겠죠? 이때 본인의 작업 공간을 &lt;strong&gt;로컬 레포지토리&lt;/strong&gt; 라고 합니다. 이때 사용하는 명령어가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git clone&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;우선 아래 이미지와 같이 복제하고자 하는 리무트 레포지토리로 가서 해당 주소를 복사합니다. &lt;strong&gt;Code&lt;/strong&gt; 라 적힌 초록색 버튼을 누르면 나오는, 아래 이미지에서 빨간 박스로 표시한 &lt;strong&gt;URL&lt;/strong&gt; 을 바로 오른쪽 &lt;strong&gt;복사 버튼&lt;/strong&gt; 을 눌러 복사해주면 됩니다.&lt;/p&gt;

&lt;figure class=&quot;&quot;&gt;
  &lt;img src=&quot;/TWIL/assets/images/1%EA%B8%B0/%EC%9D%B4%ED%83%9C%ED%98%84/0%EC%A3%BC%EC%B0%A8/1.png&quot; alt=&quot;this is test&quot; /&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/1.png&quot; alt=&quot;GitHub clone URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 아래 이미지처럼 본인이 이를 복제하길 원하는 폴더로 이동하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git clone&lt;/code&gt; 명령어 뒤에 빨간 박스로 표시한 부분처럼 본인이 복제한 &lt;strong&gt;URL&lt;/strong&gt; 을 입력하여 복제합니다. 그리고 확인해보면 처음 디렉토리 내에 들어 있는 파일들을 보여주는 명령어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ls&lt;/code&gt; 을 입력했을 때와 달리 그다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ls&lt;/code&gt; 를 입력했을 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TWIL&lt;/code&gt; 이라는 폴더가 정상적으로 복제된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/1기/이태현/0주차/2.png&quot; alt=&quot;git clone command&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;git-branch-와-git-checkout-명령어&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git branch&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git checkout&lt;/code&gt; 명령어&lt;/h4&gt;
&lt;p&gt;이제 복제한 폴더로 이동해보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 브랜치라고 적혀있는 걸 확인할 수 있습니다. 이는 각자의 터미널 셋팅마다 안 보일 수도 있는데 만약 보이지 않을 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 브랜치라고 알고 계시면 됩니다. 혹시 IDE로 비주얼 스튜디어 코드(VSC)를 사용하고 계실 경우 아래 이미지와 같이 브랜치를 알려줍니다. 물론 다른 IDE도 이러한 기능을 제공해주고 있으니 한 번 확인해보시면 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/3.png&quot; alt=&quot;check branch by ide&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;strong&gt;브랜치(branch)&lt;/strong&gt; 라는 개념에 대해 짧게 짚고 넘어가겠습니다. 영어로 &lt;strong&gt;가지&lt;/strong&gt; :herb: 를 의미하는 것처럼 브랜치 또한 뻗어나가는 개념이라고 생각하시면 편합니다.&lt;/p&gt;

&lt;p&gt;브랜치는 아래 이미지와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt; 등으로 이름 짓는 가장 최초의 브랜치를 기준으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이태현&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;김태현&lt;/code&gt; 과 같이 &lt;strong&gt;개별적인 작업 공간&lt;/strong&gt; 으로 뻗어 나가는 개념입니다. 다시 말해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이태현&lt;/code&gt; 이라는 브랜치를 만들어 제가 해당 브랜치에서 작업을 하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;김태현&lt;/code&gt; 이라는 브랜치를 만들어 다른 사람은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;김태현&lt;/code&gt; 브랜치에서 작업을 진행하는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/4.png&quot; alt=&quot;branch concept&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 브랜치라는 개념은 왜 만들어졌을까요? 어떤 소프트웨어를 만들 때 사실 단 몇 줄의 코드로 서비스 또는 제품이 만들어지는 경우는 없습니다. 당장 우리가 실생활에서 사용 중인 카카오톡만 생각하더라도 &lt;strong&gt;어마어마하게 많은 소스 코드들&lt;/strong&gt; 로 이루어져있지 않을까요? 이때 각자가 분업을 통해 버전 관리와 유지 보수, 또 작업 자체를 효율적으로 하려고 등장했습니다.&lt;/p&gt;

&lt;p&gt;위 이미지를 예로 볼 경우 제가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이태현&lt;/code&gt; 이라는 브랜치를 만들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;김태현&lt;/code&gt; 브랜치와 &lt;strong&gt;독립적으로 작업을 진행한다면 다른 곳에서의 진행 상황에 종속적이지 않고 원활하게 작업을 진행&lt;/strong&gt; 할 수 있게 됩니다. 이것이 바로 브랜치의 핵심 개념입니다.&lt;/p&gt;

&lt;p&gt;이제 터미널에 아래 이미지와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git branch&lt;/code&gt; 명령어를 입력해봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/5.png&quot; alt=&quot;git branch command&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러면 아래와 같이 현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 브랜치 하나만 존재하는 걸 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/6.png&quot; alt=&quot;git branch result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 아래 이미지와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git branch&lt;/code&gt; 명령어 뒤에 생성하고자 하는 브랜치 이름을 적어 본인이 독립적으로 작업할 공간을 만들어줍니다. &lt;strong&gt;우리의 TWIL 프로젝트에서는 본인의 깃헙 아이디가 브랜치 이름이 됩니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/7.png&quot; alt=&quot;git branch create&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 다시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git branch&lt;/code&gt; 명령어를 입력하면 아래 이미지와 같이 기존의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 브랜치 외에 본인이 방금 만든 브랜치가 추가되어 있는 걸 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/8.png&quot; alt=&quot;git branch result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 이제 &lt;strong&gt;본인이 만든 브랜치로 이동&lt;/strong&gt; 하여, 다시 말해 기존의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 브랜치에서 위 예시에서는 제가 만든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0417taehyun&lt;/code&gt; 브랜치로 이동하여 작업을 진행해야 합니다. 이때 사용하는 명령어가 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git checkout&lt;/code&gt; 명령어 입니다. 마치 숙박 업소에서 체크아웃을 하는 것과 같은 개념입니다. 유의할 점은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git checkout&lt;/code&gt; 명령어 뒤에 와야할 브랜치는 내가 가고자 하는 브랜치의 이름입니다. 따라서 위 예시에서는 현재 내가 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 브랜치에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0417taehyun&lt;/code&gt; 브랜치로의 이동을 원하는 것이기에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git checkout 0417taehyun&lt;/code&gt; 명령어를 입력합니다.&lt;/p&gt;

&lt;p&gt;이 과정을 거치면 아래 이미지와 같이 정상적으로 브랜치를 이동한 걸 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/9.png&quot; alt=&quot;git branch result&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;pull-request&quot;&gt;Pull Request&lt;/h4&gt;
&lt;p&gt;이제 본인의 브랜치에서 작업을 다 했다면 이를 우리의 리무트 레포지토리로 옮겨줘야 합니다. 그래야 내 컴퓨터에만 존재하는 소스 코드, 공부 내용 등이 타인과 공유가 가능해지기 때문입니다.&lt;/p&gt;

&lt;p&gt;이때 사용하는 명령어의 묶음이 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git add&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git commit&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git push&lt;/code&gt; 입니다.&lt;/p&gt;

&lt;p&gt;아래 이미지를 통해, 그리고 편지 보내는 예시를 통해 가볍게 알아보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git add&lt;/code&gt; 는 말 그대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git&lt;/code&gt; 이라는 프로그램에 “나 이제 보낼거야!” 라고 공지하는 것과 같습니다. 따라서 편지를 보내기 위해 편지지를 사고 준비하는 과정입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git commit&lt;/code&gt; 는 이제 무엇이라 보낼지 결정해서 말해주는 걸 의미합니다. 한 마디로 편지지의 제목을 적는다고 생각하면 편한데 아래 이미지르 볼 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[ 이태현 ] Issue &amp;amp; Pull Request 템플릿 추가&lt;/code&gt; 라는 제목으로 보낸다고 생각하시면 됩니다. 여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-m&lt;/code&gt; 옵션은 바로 한 줄로 옆에 적을 수 있는 옵션을 의미하고 기본 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git commit&lt;/code&gt; 을 사용하실 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vim&lt;/code&gt; 과 같은 본인이 설정한 IDE가 등장하여 조금 더 많은 줄에 내용을 적을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git push&lt;/code&gt; 는 이제 주소를 적어 실제로 편지를 보내는 과정입니다. 아래 예시의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 으로 부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;origin&lt;/code&gt; 이라는 곳으로 최종적으로 편지를 보내게 됩니다. 이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;origin&lt;/code&gt; 은 우리의 리무트 레포지토리를 의미한다고 생각하시면 편합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/10.png&quot; alt=&quot;git push&quot; /&gt;&lt;/p&gt;

&lt;p&gt;원래는 &lt;strong&gt;스테이징&lt;/strong&gt; 등과 같은 여러 개념에 대한 설명이 필요하지만 단순히 일련의 과정을 거쳐 내가 로컬에서 작성한 코드를 리무트로 옮긴다고만 이해하셔도 좋습니다. 물론 무조건적으로 알아야 하는 개념이라고 생각하니 다른 곳에서 더 자세히 알아보실 것을 추천드립니다!&lt;/p&gt;

&lt;p&gt;이렇게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git push&lt;/code&gt; 까지 완료하면 리무트 레포지토리로 본인이 작성한 글이 넘어갑니다. 위 예시에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 브랜치에서 작성했지만 실제로 본인이 만든 브랜치에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git push&lt;/code&gt; 를 할 경우 아래와 같이 리무트 레포지토리에서 &lt;strong&gt;Pull Request&lt;/strong&gt; 를 생성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이때 병합이 되지 않는 첫 번째 Pull Request의 경우 아래 이미지에서 빨간 박스로 표시한 빈 공간에 자동으로 만들겠냐는 질문이 뜨게 됩니다. 만약 한 번 병합이 된 경우 오른쪽 상단의 &lt;strong&gt;New pull request&lt;/strong&gt; 라 적힌 초록 버튼을 눌러줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/11.png&quot; alt=&quot;pull request&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러면 아래 이미지와 같이 Pull Request를 생성할 수 있습니다. 이때 빨간 박스와 같이 &lt;strong&gt;본인의 브랜치를 선택&lt;/strong&gt; 한 뒤 바로 우측 아래 &lt;strong&gt;Creat pull request&lt;/strong&gt; 버튼을 눌러줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/12.png&quot; alt=&quot;new pull request&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래 이미지와 같이 Pull Request가 생성됩니다. 제가 미리 만들어 둔 확인 사항을 반드시 읽어주세요. 이때 제목은 본인이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git commit&lt;/code&gt; 때 작성한 내용이 제목으로 작성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/13.png&quot; alt=&quot;pull request&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래 이미지와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[ ]&lt;/code&gt; 로 작성된 확인 사항들을 하나씩 확인한 뒤 정상적으로 진행을 완료하였다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[x]&lt;/code&gt; 와 같이 체크 표시를 해주고 우측 하단 &lt;strong&gt;Create pull request&lt;/strong&gt; 라 적힌 초록 버튼을 눌러줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/14.png&quot; alt=&quot;check pull request&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러면 아래 이미지와 같이 정상적으로 Pull Request가 생성됩니다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/15.png&quot; alt=&quot;pull request completed&quot; /&gt;&lt;/p&gt;

&lt;p&gt;끝으로 슬랙에 알림이 온 걸 확인합니다. 다른 사람들이 작성한 글에도 열심히 반응해주세요&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;./Images/2021.07.04/16.png&quot; alt=&quot;slack notification&quot; /&gt;&lt;/p&gt;</content><author><name>이주</name></author><category term="1기" /><summary type="html">오리엔테이션 목적 TWIL(This Week I Learned) 의 목적은 메인 README.md에서 확인하실 수 있는 것처럼 마치 소셜 네트워크 서비스를 이용하듯 각자가 공부한 내용을 쉽고 편하게 공유하는 데 있습니다. 따라서 본인이 글을 쓰기로 결정한 주제에 대해 깊이 있게 조사하고 공부하는 것은 물론 이를 TWIL 멤버를 비롯한 다른 누가 읽더라도 알기 쉽도록 적는 게 목표입니다. 물론 개인적인 생각에는 알기 쉽게 풀어내는 과정에서 자연스레 본인이 몰랐던 개념들을 포함하여 해당 주제를 깊게 공부할 수밖에 없다고 생각합니다</summary></entry></feed>